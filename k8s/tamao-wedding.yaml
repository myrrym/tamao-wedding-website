# ==============================================================================
# 1. Persistent Volume Claim for Laravel Storage
#
# This reserves a piece of physical storage for your application. The 'storage'
# directory in your Laravel app (for logs, file uploads, etc.) will be
# mapped here. This ensures that even if a pod restarts, your data is safe.
# ==============================================================================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: laravel-storage-pvc
spec:
  # ReadWriteOnce is sufficient here and supported by most storage providers.
  # It means the volume can be mounted as read-write by a single node.
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      # Adjust the storage size as needed for your application.
      storage: 5Gi
  # storageClassName: "your-storage-class" # Optional: Uncomment and specify if you use a non-default storage class (e.g., gp2 on AWS, premium-rwo on GKE).

---
# ==============================================================================
# 2. Secret for Laravel Environment Variables (.env)
#
# NEVER hardcode secrets in your Docker image. This resource stores your
# .env file content securely. You must create this secret in your cluster
# *before* deploying the application.
#
# HOW TO CREATE THIS SECRET:
# 1. Create a file named '.env' with your production settings.
# 2. Run this command in your terminal:
#    kubectl create secret generic laravel-env --from-file=.env
# ==============================================================================
# This is a placeholder. You must create the secret yourself.
# Example of creating the secret manually if needed:
# apiVersion: v1
# kind: Secret
# metadata:
#   name: laravel-env
# type: Opaque
# data:
#   # The value here is your entire .env file, base64 encoded.
#   # To get this value, run: base64 -w 0 .env
#   .env: "YOUR_BASE64_ENCODED_DOT_ENV_CONTENT_HERE"

---
# ==============================================================================
# 3. ConfigMap for NGINX Configuration
#
# This holds the nginx.conf file. Using a ConfigMap allows you to manage
# the configuration without rebuilding your NGINX image.
# ==============================================================================
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-conf
data:
  nginx.conf: |
    server {
        listen 80;
        server_name _;
        root /var/www/html/public;
        index index.php index.html;

        # Standard location block
        location / {
            try_files $uri $uri/ /index.php?$query_string;
        }

        # Health check for NGINX
        location /nginx-health {
            access_log off;
            return 200 "healthy";
        }

        # Location block for PHP files
        location ~ \.php$ {
            try_files $uri =404;
            fastcgi_split_path_info ^(.+\.php)(/.+)$;

            # This is the crucial part: it passes the request to the
            # PHP-FPM service on its designated port.
            # 'php-fpm-service' is the name of our internal PHP service defined below.
            fastcgi_pass php-fpm-service:9000;

            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_path_info;
        }

        # Block access to .htaccess files
        location ~ /\.ht {
            deny all;
        }
    }

---
# ==============================================================================
# 4. Deployment for PHP-FPM
#
# This manages the pods running your actual Laravel application image.
# It mounts the secret and the persistent volume.
# ==============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: php-fpm-deployment
spec:
  replicas: 1 # Start with 2 replicas for high availability
  selector:
    matchLabels:
      app: php-fpm
  template:
    metadata:
      labels:
        app: php-fpm
    spec:
      imagePullSecrets:
      - name: github-pat
      containers:
        - name: php-fpm
          # YOUR DOCKER IMAGE
          image: ghcr.io/myrrym/tamao-wedding:0.0.7
          imagePullPolicy: IfNotPresent 
          ports:
            - containerPort: 9000
          # Use the healthcheck script from your Dockerfile
          readinessProbe:
            exec:
              command: ["docker-healthcheck"]
            initialDelaySeconds: 15
            periodSeconds: 10
          livenessProbe:
            exec:
              command: ["docker-healthcheck"]
            initialDelaySeconds: 30
            periodSeconds: 20
          volumeMounts:
            # Mount the .env file from the secret into the container
            - name: laravel-env-volume
              mountPath: /var/www/html/.env
              subPath: .env
            # Mount the persistent storage
            - name: laravel-storage
              mountPath: /var/www/html/storage
      volumes:
        - name: laravel-env-volume
          secret:
            secretName: laravel-env
        - name: laravel-storage
          persistentVolumeClaim:
            claimName: laravel-storage-pvc

---
# ==============================================================================
# 5. Service for PHP-FPM
#
# This creates a stable internal network endpoint for your PHP-FPM pods.
# NGINX will use the name 'php-fpm-service' to send requests to these pods.
# Type: ClusterIP means it's only accessible inside the Kubernetes cluster.
# ==============================================================================
apiVersion: v1
kind: Service
metadata:
  name: php-fpm-service
spec:
  type: ClusterIP
  selector:
    app: php-fpm
  ports:
    - protocol: TCP
      port: 9000
      targetPort: 9000

---
# ==============================================================================
# 6. Deployment for NGINX
#
# This manages the pods running the NGINX web server. It mounts the
# NGINX config and also the shared storage to serve user-uploaded files.
# ==============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      initContainers:
        - name: copy-app-public
          image: ghcr.io/myrrym/tamao-wedding:0.0.7 # Use the same app image
          command: ['sh', '-c', 'cp -r /var/www/html/public/. /app-public']
          volumeMounts:
            - name: app-public-volume
              mountPath: /app-public
      containers:
        - name: nginx
          image: nginx:1.25-alpine
          ports:
            - containerPort: 80
          volumeMounts:
            # Mount the NGINX configuration from the ConfigMap
            - name: nginx-conf-volume
              mountPath: /etc/nginx/conf.d/default.conf
              subPath: nginx.conf
            # Mount the storage volume to serve files from public/storage
            - name: laravel-storage
              mountPath: /var/www/html/public/storage
              readOnly: true
            # FIX: Mount the shared public assets from the initContainer
            - name: app-public-volume
              mountPath: /var/www/html/public
      volumes:
        - name: nginx-conf-volume
          configMap:
            name: nginx-conf
        - name: laravel-storage
          persistentVolumeClaim:
            claimName: laravel-storage-pvc
        # FIX: Define the in-memory volume for public assets
        - name: app-public-volume
          emptyDir: {}

---
# ==============================================================================
# 7. Service for NGINX
#
# This exposes the NGINX deployment to the internet.
# Type: LoadBalancer will provision an external load balancer on most
# cloud providers (GCP, AWS, Azure). For local testing (Minikube, Docker
# Desktop), you might change this to NodePort.
# ==============================================================================
apiVersion: v1
kind: Service
metadata:
  name: laravel-service
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80 # The port the service will be available on
      targetPort: 80 # The port on the NGINX pods to forward traffic to

---

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: laravel-ingress
  annotations:
    kubernetes.io/ingress.class: "nginx"
spec:
  rules:
  - host: tamaowedding.k3s.nekopaw.net  # Replace with your desired hostname
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: laravel-service
            port:
              number: 80
  tls:
    - hosts:
      - tamaowedding.k3s.nekopaw.net
      secretName: star.k3s.nekopaw.net
